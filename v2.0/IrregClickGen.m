function [waveOutput,  irregICISampNBase] = IrregClickGen(ICIs, Duration, Amp, varargin)
% ICI: inter-click interval (ms), n*1 vector
% Duration: duration of click train (ms), n*1 vector
% Amp: amplitude of a single click, less or equal than 1
% fs: sample rate of the signal, default:97656
% baseICI: generate a reference Irreg click train with an average of baseICI(defalt: 4ms), the result
%          will then be generated by scaling the reference one.
% variance: Since the ICIs of irreg click train follows gaussion
%          distribution, the sigma = u/ variance, where u is the input parameter "ICI" 

% example: IrregWave = IrregClickGen(6, 300, 1, "baseICI", 4, "variance", 2, "fs", 97656);
mIp = inputParser;
mIp.addRequired("ICIs", @(x) validateattributes(x, 'numeric', {'vector'}));
mIp.addRequired("Duration", @(x) validateattributes(x, 'numeric', {'positive'}));
mIp.addRequired("Amp", @(x) validateattributes(x, 'numeric', {'numel', 1, 'positive'}));
mIp.addParameter("baseICI", 4, @(x) validateattributes(x, 'numeric', {'numel', 1, 'positive'}));
mIp.addParameter("variance", 2, @(x) validateattributes(x, 'numeric', {'numel', 1, 'positive'}));
mIp.addParameter("fs", 97656, @(x) validateattributes(x, 'numeric', {'numel', 1, 'positive'}));
mIp.addParameter("irregICISampNBase", [], @(x) validateattributes(x, 'numeric', {'vector', 'positive'}));
mIp.addParameter("ICIRangeRatio", [0.3, 1.7], @(x) validateattributes(x, 'numeric', {'2d', 'positive'}));
mIp.addParameter("repHead", []);
mIp.addParameter("repTail", []);
mIp.addParameter("lastClick", false, @(x) any([islogical(x), isnumeric(x)]));
mIp.parse(ICIs, Duration, Amp, varargin{:});

fs = mIp.Results.fs;
baseICI = mIp.Results.baseICI;
variance = mIp.Results.variance;
opts.ICIRangeRatio = mIp.Results.ICIRangeRatio;
repHead = mIp.Results.repHead;
repTail = mIp.Results.repTail;
irregICISampNBase = mIp.Results.irregICISampNBase;
lastClick = logical(mIp.Results.lastClick);

% ICI Range validation
if prod(opts.ICIRangeRatio - 1) >= 0
    error("invalid ICI Range!");
end


if size(ICIs, 1) ~= numel(ICIs)
    ICIs = ICIs';
end
if size(Duration, 1) ~= numel(Duration)
    Duration = Duration';
end
%% generate single click
opts.fs = fs;
opts.Amp = Amp;
opts.clickDur = 0.2 ; % ms
opts.riseFallTime = 0; % ms
click = generateClick(opts);

%% for single click train
opts.click = click;
opts.trainLength = 100; % ms, single train
opts.soundLength = Duration; % ms, sound length, composed of N single trains
opts.ICIs = ICIs; % ms

opts.baseICI =  baseICI; % ms
opts.sigmaPara = variance; % sigma = Î¼ / sigmaPara
if isempty(irregICISampNBase)
    irregICISampNBase = cell2mat(irregICISampN(opts));
    opts.irregICISampNBase = irregICISampNBase;
else
    opts.irregICISampNBase = irregICISampNBase;
end
if ~isempty(find(repHead > 0, 1))
    opts.irregICISampNBase(1 : length(repHead)) = ceil(baseICI/1000*opts.fs * repHead);
end
if ~isempty(find(repTail > 0, 1))
    opts.irregICISampNBase(end-length(repTail)+1 : end) = ceil(baseICI/1000*opts.fs * repTail);
end

singleIrregWave = generateIrregClickTrain(opts);
if lastClick
    singleIrregWave = cellfun(@(x) [x; click'], singleIrregWave, "UniformOutput", false);
end

c_ICIs = num2cell(ICIs);
c_Wave = singleIrregWave;
c_OnsetIdx = cellfun(@(x) [1; find(diff(x) > 0) + 1], singleIrregWave, "uni", false);
c_SampN = cellfun(@(x) diff(x), c_OnsetIdx, "uni", false);
c_LastClickOnset = cellfun(@(x) x(end)/opts.fs*1000, c_OnsetIdx, "UniformOutput", false);
c_Duration = cellfun(@(x) length(x)/opts.fs*1000, singleIrregWave, "UniformOutput", false);
c_fs = num2cell(repmat(opts.fs, length(ICIs), 1));
waveOutput = cell2struct([c_ICIs, c_Wave, c_fs, c_OnsetIdx, c_SampN, c_LastClickOnset, c_Duration], ["ICIs", "Wave", "fs", "OnsetIdx", "SampN", "LastClickOnset", "Duration"], 2);
end